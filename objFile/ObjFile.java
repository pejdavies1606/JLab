package geometry_test;

import java.util.List;
import java.util.ArrayList;
import org.jlab.geom.prim.*;
import java.io.*;

public class ObjFile {

	private List<ObjShape> mShapes;
	private String mFilename;
	
	public ObjFile() {
		mShapes = new ArrayList<ObjShape>();
	}
	
	public ObjFile( String aFilename  ) {
		mShapes = new ArrayList<ObjShape>();
		setFilename( aFilename );
	}
	
	public void setFilename( String aFilename ) {
		mFilename = aFilename;
	}
	
	public List<ObjShape> getShapes() {
		return mShapes;
	}
	
	public void newShape( Triangle3D aTriangle3D, String aName ) {
		List<Point3D> points = new ArrayList<Point3D>();
		for( int i = 0; i < 3; i++ ) {
			points.add( aTriangle3D.point(i) );
		}
		List<int[]> faces = new ArrayList<int[]>();
		faces.add( new int[]{1,2,3} ); // local vertex indices
		mShapes.add( new ObjShape( points, faces, aName ) );
	}
	
	public void newShape( Shape3D aShape3D, String aName ) {
		
		Face3D[] faces = new Face3D[ aShape3D.size() ]; // each Face3D of a Shape3D always has 3 points (Triangle3D)
		List<Point3D> pointList = new ArrayList<Point3D>();
		
		// construct non-degenerate list of points
		for( int i = 0; i < faces.length; i++) { 
			faces[i] = aShape3D.face(i);
			
			/*System.out.println("pointList i="+i);
			for( int k = 0; k < pointList.size(); k++ ) {
				System.out.println( (int) pointList.get( k ).x() + " " + (int) pointList.get( k ).y() + " " + (int) pointList.get( k ).z() );
			}*/
			
			for( int j = 0; j < 3; j++ ) {
				//System.out.println( (int) faces[i].point(j).x() + " " + (int) faces[i].point(j).y() + " " + (int) faces[i].point(j).z() + " ?");
				if( !_checkpointList( pointList, faces[i].point(j) ) ) { // cannot not use contains() as it doesn't check things properly
					pointList.add( faces[i].point(j) );
					//System.out.println( (int) faces[i].point(j).x() + " " + (int) faces[i].point(j).y() + " " + (int) faces[i].point(j).z() + " *");
				}
			}
		}
		
		/*System.out.println("pointList");
		for( int k = 0; k < pointList.size(); k++ ) {
			System.out.println( pointList.get(k).x() + " " + pointList.get(k).y() + " " + pointList.get(k).z() );
		}*/
		
		// construct list of references		
		List<int[]> refsList = new ArrayList<int[]>();
		// each face of the shape gets a 'f v1 v2 v3...' line in the obj file
		for( int i = 0; i < faces.length; i++ ) {
			int[] refs = new int[3];
			for( int j = 0; j < 3; j++ ) {
				for( int k = 0; k < pointList.size(); k++ ) {
					if( _checkPointEqual( faces[i].point(j), pointList.get(k) ) ) {
						refs[j] = k+1;
					}
				}
			}
			refsList.add(refs);
		}
		
		/*System.out.println("refsList");
		for( int k = 0; k < refsList.size(); k++ ) {
			System.out.println( refsList.get(k)[0] + " " + refsList.get(k)[1] + " " + refsList.get(k)[2] );
		}*/
		
		mShapes.add( new ObjShape( pointList, refsList, aName ) );
	}
	
	/*public void transform( Transformation3D aTransform ) {
		
	}*/
	
	public void scale( double aScaleX, double aScaleY, double aScaleZ ) {
		// multiply every point in ObjFile by a scale factor
		// this is necessary because the y coordinate must be inverted (scaleY=-1) to convert from the CLAS frame to the Processing frame
		for( int s = 0; s < mShapes.size(); s++ ) {
			ObjShape shape = mShapes.get(s);
			List<Point3D> pointsList = shape.getPointsList();
			for( int i = 0; i < pointsList.size(); i++ ) {
				Point3D point = pointsList.get(i);
				point.set( point.x()*aScaleX, point.y()*aScaleY, point.z()*aScaleZ );
				pointsList.set( i, point );
			}
			shape.replacePoints( pointsList );
		}
	}
	
	public void write() throws IOException {
		FileWriter fOut = null;
		try {
			fOut = new FileWriter( mFilename );
			fOut.write( "# This file was generated by a java program. \n" );
			fOut.write("# number of objects in this file: " + mShapes.size() + "\n" );
			int refLengthTotal = 0, refLength = 0; // needed to account for global reference numbers 
			for( int s = 0; s < mShapes.size(); s++ ) {
				ObjShape shape = mShapes.get(s);
				fOut.write("o " + shape.getName() + "\n" );
				
				List<Point3D> points = shape.getPointsList();
				for( int v = 0; v < points.size(); v++ ) {
					Point3D point = points.get(v);
					fOut.write( "v " + point.x() + " " + point.y() + " " + point.z() + "\n" ); // y=-y to transform into Processing frame
				}
				
				List<int[]> refsList = shape.getRefsList();
				for( int f = 0; f < refsList.size(); f++ ) {
					int[] refs = refsList.get(f);
					fOut.write("f");
					for( int r = 0; r < refs.length; r++ ) {
						fOut.write(" " + (refLengthTotal + refs[r]) ); // global reference numbers
					}
					fOut.write("\n");
					refLength = refs.length;
				}
				refLengthTotal += refLength; // get refs.length out of for(f) scope
			}
		} finally {
			if( fOut != null ) {
				fOut.close();
			}
		}
	}
	
	private static boolean _checkpointList( List<Point3D> apointList, Point3D aPoint ) {
		if( apointList == null || aPoint == null ) {
			return false;
		}
		for( int i = 0; i < apointList.size(); i++ ) {
			if( _checkPointEqual( apointList.get(i), aPoint ) ) {
				return true;
			}
		}
		return false;
	}
	
	private static boolean _checkPointEqual( Point3D aPoint1, Point3D aPoint2 ) {
		if( Math.abs( aPoint1.distance( aPoint2 ) ) < 1e-6 ) {
			return true;
		}
		return false;
	}

}
